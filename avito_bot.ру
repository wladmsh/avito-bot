import asyncio
import aiohttp
import os
import json
import re
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from bs4 import BeautifulSoup

# ==================== ENV ====================
TOKEN = os.getenv("TELEGRAM_TOKEN")
ADMIN_ID = int(os.getenv("CHAT_ID"))

bot = Bot(token=TOKEN, parse_mode="HTML")
dp = Dispatcher(storage=MemoryStorage())

# ==================== STORAGE ====================
TASKS_FILE = "tasks.json"
tasks = {}

def load_tasks():
    if os.path.exists(TASKS_FILE):
        with open(TASKS_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    return {}

def save_tasks():
    with open(TASKS_FILE, "w", encoding="utf-8") as f:
        json.dump(tasks, f, ensure_ascii=False, indent=2)

tasks = load_tasks()

# ==================== FSM ====================
class AddTask(StatesGroup):
    url = State()
    name = State()
    min_price = State()
    max_price = State()

# ==================== KEYBOARD ====================
def main_kb():
    return InlineKeyboardMarkup(inline_keyboard=[
        [[InlineKeyboardButton(text="Добавить задание", callback_data="add")],
        [InlineKeyboardButton(text="Список заданий", callback_data="list")]
    ])

# ==================== HANDLERS ====================
@dp.message(Command("start"))
async def start(message: types.Message):
    if message.from_user.id != ADMIN_ID:
        return
    await message.answer("Avito-снайпер онлайн", reply_markup=main_kb())

@dp.callback_query(lambda c: c.data == "add")
async def add_task(cb: types.CallbackQuery, state: FSMContext):
    await cb.message.edit_text("Пришли ссылку Avito с фильтрами и сортировкой «По дате»")
    await state.set_state(AddTask.url)

@dp.message(AddTask.url)
async def get_url(m: types.Message, state: FSMContext):
    if "avito.ru" not in m.text:
        await m.answer("Это не ссылка Avito")
        return
    await state.update_data(url=m.text.strip())
    await m.answer("Как назовёшь задание?")
    await state.set_state(AddTask.name)

@dp.message(AddTask.name)
async def get_name(m: types.Message, state: FSMContext):
    await state.update_data(name=m.text.strip())
    await m.answer("Минимальная цена? (0 = без минимума)")
    await state.set_state(AddTask.min_price)

@dp.message(AddTask.min_price)
async def get_min(m: types.Message, state: FSMContext):
    p = re.sub(r"\D", "", m.text)
    min_p = int(p) if p and int(p) > 0 else None
    await state.update_data(min_price=min_p)
    await m.answer("Максимальная цена?")
    await state.set_state(AddTask.max_price)

@dp.message(AddTask.max_price)
async def get_max(m: types.Message, state: FSMContext):
    p = re.sub(r"\D", "", m.text)
    if not p:
        await m.answer("Нужно число")
        return
    data = await state.get_data()
    tid = str(len(tasks) + 1)
    tasks[tid] = {
        "name": data["name"],
        "url": data["url"],
        "min_price": data.get("min_price"),
        "max_price": int(p),
        "seen": [],
        "active": True
    }
    save_tasks()
    await m.answer(f"Задание «{data['name']}» добавлено и работает!", reply_markup=main_kb())
    await state.clear()

@dp.callback_query(lambda c: c.data == "list")
async def show_list(cb: types.CallbackQuery):
    if not tasks:
        await cb.message.edit_text("Заданий нет", reply_markup=main_kb())
        return
    text = "<b>Активные задания:</b>\n\n"
    for i, t in tasks.items():
        mn = f"от {t['min_price']:,} ₽ " if t['min_price'] else ""
        text += f"<b>{i}. {t['name']}</b>\n{mn}до {t['max_price']:,} ₽\n\n"
    await cb.message.edit_text(text, reply_markup=main_kb())

# ==================== WATCHER ====================
async def watcher():
    headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"}
    async with aiohttp.ClientSession(headers=headers) as session:
        while True:
            for task in list(tasks.values()):
                if not task.get("active", True):
                    continue
                try:
                    async with session.get(task["url"], timeout=30) as resp:
                        if resp.status != 200:
                            continue
                        html = await resp.text()
                    soup = BeautifulSoup(html, "html.parser")
                    for item in reversed(soup.find_all("div", {"data-marker": "item"})):
                        try:
                            a = item.find("a", {"data-marker": "item-title"})
                            if not a: continue
                            link = "https://www.avito.ru" + a["href"]
                            ad_id = re.search(r"_(\d+)", link).group(1)
                            if ad_id in task["seen"]: continue

                            price_tag = item.find("meta", {"itemprop": "price"})
                            if not price_tag: continue
                            price = int(price_tag["content"])

                            if task["min_price"] and price < task["min_price"]: continue
                            if price > task["max_price"]: continue

                            title = a.get("title") or a.get_text(strip=True)
                            location = item.find("div", {"data-marker": "item-address"})
                            loc_text = location.get_text(strip=True) if location else ""

                            photo = item.find("img", {"itemprop": "image"})
                            photo_url = photo["src"] if photo and "stub" not in photo.get("src","") else None

                            msg = f"<b>Новое • {task['name']}</b>\n\n<b>{title}</b>\n<b>{price:,} ₽</b>\n{loc_text}\n\n{link}"

                            if photo_url:
                                await bot.send_photo(ADMIN_ID, photo_url, caption=msg)
                            else:
                                await bot.send_message(ADMIN_ID, msg, disable_web_page_preview=True)

                            task["seen"].append(ad_id)
                            if len(task["seen"]) > 3000:
                                task["seen"] = task["seen"][-2000:]
                            save_tasks()
                            await asyncio.sleep(1.2)
                        except:
                            continue
                except:
                    continue
            await asyncio.sleep(70)

# ==================== START ====================
async def on_startup(_):
    await bot.send_message(ADMIN_ID, "Бот запущен — мониторю Avito 24/7")

async def main():
    asyncio.create_task(watcher())
    dp.startup.register(on_startup)
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
