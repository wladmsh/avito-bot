import asyncio
import aiohttp
import os
import json
import re
import logging

from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from bs4 import BeautifulSoup
from dotenv import load_dotenv

# ===================== ENV =====================
load_dotenv()
TOKEN = os.getenv("TELEGRAM_TOKEN")
ADMIN_ID = int(os.getenv("CHAT_ID"))

# ===================== BOT =====================
bot = Bot(token=TOKEN, parse_mode="HTML")
dp = Dispatcher(storage=MemoryStorage())
logging.basicConfig(level=logging.INFO)

# ===================== STORAGE =====================
TASKS_FILE = "tasks.json"

def load_tasks():
    if os.path.exists(TASKS_FILE):
        with open(TASKS_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    return {}

def save_tasks():
    with open(TASKS_FILE, "w", encoding="utf-8") as f:
        json.dump(tasks, f, ensure_ascii=False, indent=2)

tasks = load_tasks()

def next_id():
    return str(max([int(i) for i in tasks.keys()] + [0]) + 1)

# ===================== FSM =====================
class AddTask(StatesGroup):
    url = State()
    name = State()
    min_price = State()
    max_price = State()

# ===================== KEYBOARDS =====================
def main_kb():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∑–∞–¥–∞–Ω–∏–µ", callback_data="add")],
        [InlineKeyboardButton(text="üìã –°–ø–∏—Å–æ–∫ –∑–∞–¥–∞–Ω–∏–π", callback_data="list")]
    ])

# ===================== COMMANDS =====================
@dp.message(Command("start"))
async def start(m: types.Message):
    if m.from_user.id != ADMIN_ID:
        return
    await m.answer("‚úÖ Avito-—Å–Ω–∞–π–ø–µ—Ä –∑–∞–ø—É—â–µ–Ω", reply_markup=main_kb())

# ===================== ADD TASK =====================
@dp.callback_query(lambda c: c.data == "add")
async def add_start(cb: types.CallbackQuery, state: FSMContext):
    await cb.message.edit_text("üîó –ü—Ä–∏—à–ª–∏ —Å—Å—ã–ª–∫—É Avito —Å —Ñ–∏–ª—å—Ç—Ä–∞–º–∏")
    await state.set_state(AddTask.url)

@dp.message(AddTask.url)
async def add_url(m: types.Message, state: FSMContext):
    if "avito.ru" not in m.text:
        await m.answer("‚ùå –≠—Ç–æ –Ω–µ —Å—Å—ã–ª–∫–∞ Avito")
        return
    await state.update_data(url=m.text.strip())
    await m.answer("‚úèÔ∏è –ù–∞–∑–æ–≤–∏ –∑–∞–¥–∞–Ω–∏–µ")
    await state.set_state(AddTask.name)

@dp.message(AddTask.name)
async def add_name(m: types.Message, state: FSMContext):
    await state.update_data(name=m.text.strip())
    await m.answer("üí∞ –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Ü–µ–Ω–∞ (0 = –±–µ–∑ –º–∏–Ω–∏–º—É–º–∞)")
    await state.set_state(AddTask.min_price)

@dp.message(AddTask.min_price)
async def add_min(m: types.Message, state: FSMContext):
    p = re.sub(r"\D", "", m.text)
    min_price = int(p) if p else 0
    await state.update_data(min_price=min_price or None)
    await m.answer("üí∞ –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Ü–µ–Ω–∞")
    await state.set_state(AddTask.max_price)

@dp.message(AddTask.max_price)
async def add_max(m: types.Message, state: FSMContext):
    p = re.sub(r"\D", "", m.text)
    if not p:
        await m.answer("‚ùå –ù—É–∂–Ω–æ —á–∏—Å–ª–æ")
        return

    data = await state.get_data()
    tid = next_id()

    tasks[tid] = {
        "name": data["name"],
        "url": data["url"],
        "min_price": data["min_price"],
        "max_price": int(p),
        "seen": [],
        "active": True
    }

    save_tasks()
    await m.answer("‚úÖ –ó–∞–¥–∞–Ω–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ", reply_markup=main_kb())
    await state.clear()

# ===================== LIST =====================
@dp.callback_query(lambda c: c.data == "list")
async def show_list(cb: types.CallbackQuery):
    if not tasks:
        await cb.message.edit_text("üì≠ –ó–∞–¥–∞–Ω–∏–π –Ω–µ—Ç", reply_markup=main_kb())
        return

    text = "<b>üìã –ó–∞–¥–∞–Ω–∏—è:</b>\n\n"
    for i, t in enumerate(tasks.values(), 1):
        text += (
            f"<b>{i}. {t['name']}</b>\n"
            f"{t.get('min_price') or 0} ‚Äî {t['max_price']} ‚ÇΩ\n"
            f"{'üü¢ –í–ö–õ' if t['active'] else 'üî¥ –í–´–ö–õ'}\n\n"
        )

    await cb.message.edit_text(text, reply_markup=main_kb())

# ===================== WATCHER =====================
async def watcher():
    headers = {"User-Agent": "Mozilla/5.0"}
    async with aiohttp.ClientSession(headers=headers) as session:
        while True:
            for t in tasks.values():
                if not t["active"]:
                    continue
                try:
                    async with session.get(t["url"], timeout=25) as r:
                        if r.status != 200:
                            continue
                        html = await r.text()

                    soup = BeautifulSoup(html, "html.parser")
                    items = soup.find_all("div", {"data-marker": "item"})

                    for item in reversed(items):
                        a = item.find("a", {"data-marker": "item-title"})
                        if not a:
                            continue

                        link = "https://www.avito.ru" + a["href"]
                        m = re.search(r"(\d+)", link)
                        if not m:
                            continue

                        ad_id = m.group(1)
                        if ad_id in t["seen"]:
                            continue

                        price_meta = item.find("meta", {"itemprop": "price"})
                        if not price_meta:
                            continue
                        price = int(price_meta["content"])

                        if t["min_price"] and price < t["min_price"]:
                            continue
                        if price > t["max_price"]:
                            continue

                        title = a.get_text(strip=True)

                        msg = (
                            f"<b>üÜï {t['name']}</b>\n"
                            f"<b>{title}</b>\n"
                            f"<b>{price} ‚ÇΩ</b>\n"
                            f"{link}"
                        )

                        await bot.send_message(ADMIN_ID, msg)

                        t["seen"].append(ad_id)
                        if len(t["seen"]) > 2000:
                            t["seen"] = t["seen"][-1500:]

                        save_tasks()
                        await asyncio.sleep(1)

                except Exception:
                    continue

            await asyncio.sleep(60)

# ===================== MAIN =====================
if __name__ == "__main__":
    import asyncio
    asyncio.run(main())

async def main():
    await dp.start_polling(bot)
